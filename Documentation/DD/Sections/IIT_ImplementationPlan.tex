From the previous analysis it emerges that the components that are more difficult to implement are the ones relative to the aggregated data visualization and intervention list generation functionalities. These components would require the higher amount of testing in order to assure that the system will work flawlessly with the minimal amount of bugs.

As first step of the implementation of SafeStreets system, the underlying database must be created. A small database populated with some dummy data should also be developed, following the same structure of the production one. This database will allow the team to test easily the API of the server, because the output of a query will be always known if after each test any modification done on this database is reversed, so that it remains untouched.

After database implementation, the next step is to develop the server API. Defining clearly the API endpoints, the input they receive and the output they produce will allow to start building the various components that handle the logic behind the API calls, based on the received parameters. Also clients could be developed in parallel as they only display data and call the defined endpoints, they only need to satisfy the required input defined in API endpoints and working on manipulating the data that is expected back, which structure is also defined by the API definition (along with possible errors). Because of these considerations, clients and server can be developed and tested in parallel by two separate teams, that have competence with the respective technologies of these subsystems.

Concerning the application server, based on the relevance and complexity of the functionality, the following order of implementation should be followed to minimize the effort and build a cohesive system. For each functionality, an high-level implementation guideline is also provided to give a general idea of the system to the developers' team and interested stakeholders:
\begin{itemize}
	\item \textbf{Login and registration:} standard in all types of web applications, this functionality should be pretty fast to implement because of already existing plugins and libraries. The only difficulty in the implementation is caused by the automatic recognition of municipalities and authorities performed by the components, done by querying the Italian public PEC register (\url{https://www.indicepa.gov.it/documentale/index.php}). The easier way we found at the time of writing is to download periodically the list of all registered PEC addresses (url: \url{https://www.indicepa.gov.it/public-services/opendata-read-service.php?dstype=FS&filename=pec.txt}), that can be used as a .csv file using tab as separator, store it in the server and check if the PEC domains given by authorities and municipalities exist and are associated to "Comuni e loro Consorzi e Associazioni" in the "Tipologia Istat" column. Implementing this component will allow to exploit the session, registered in the server after each client signs in, and this is important in about all functionalities because accessible data and services differs based on account type.
	\item \textbf{Report submission:} this functionality is essential for the whole system, without the reports sent by the user all others functionalities would be useless because of the absence of data. Considering this fact, this functionality needs to be implemented first in the server and exhaustively tested to check that valid report are received, completed and stored in the database correctly, while invalid ones are refused returning a proper error, following the API definition. This component is also tied to the external OCR service, so it's important to choose a quality service with an easily accessible interface for performing the license plate recognition. Also, when receiving the report it communicates with the Map service in order to complete the metadata associated with the report.
	\item \textbf{Report detail visualization:} this functionality is pretty simple to implement server-side and not time consuming. It offers two kinds of requests: the first one is about the list of reports accessible by the requesting user and the second one is about the request of a single report. This can be done respectively by checking what type of account made the request, by checking the active sessions database, then adapt the query to perform on the main database based on the account info for retrieving the accessible list of reports, instead for single report access the component just needs to check with some predicates if the client can retrieve that report. Moreover, this functionality is essential for authorities registered to the system, as their main focus is to check the reports and their validity to efficiently patrol the city and punish the transgressors, so it's advisable to implement it earlier.
	\item \textbf{Intervention generation:} one of the most complex functionality of the system, shouldn't be implemented too late because it's the target service for a whole type of stakeholders (municipalities) and because of this needs proper testing before software release. Both InterventionManager and MunicipalityDataIntegrationManager components are involved in this functionality realization and need to coordinate together to reach the goal. Firstly, MunicipalityDataIntegrationManager must be implemented, because it's used by InterventionManager before starting the main computation of the interventions. Data integration is performed through the municipality's API that made the request for interventions, so the account info must be retrieved through checks on session and main databases. If the API is consistent with the guidelines defined by SafeStreets, the component will be able to retrieve the data and then integrate it in the database with an insert operation, otherwise it will return an error. In either cases, the InterventionManager starts the algorithm for finding the interventions relative to the municipality's area. The discriminating factors for defining consistent and valid interventions are the density of the violations in a relative small area, then the presence of a certain percentage of a violation type or a combination of them, these two pieces of info allows the possibility to define sensible intervention for the analyzed situation.
	\item \textbf{Report validation:} this feature is quite simple to implement, as the only thing that the relative component should do is to update the affected report tuple in the database and add the authority's id to the supervisor field (returned by checking session and main databases like other components). This functionality is not really important customer side, because it only allows the clients to better organize the visualization of the report lists as the validation in the system holds no legal value and the authorities need to actually check the violations in place, but it's really important to provide accurate results in aggregate data visualization, as only validated reports and the one imported by the municipalities' API will be used for the statistics.
	\item \textbf{Aggregated data visualization:} complex feature both client-side and server-side. It's implemented as last functionality because it's not strictly necessary for fulfilling the main service of the system of allowing the violation reporting flow from citizens to authorities, but will provide interesting data for both citizen, authorities and municipalities, that can be used to have a better understanding and awareness of the situation in their city. It's also implemented as last because it indirectly depends from other services, because it queries the reports sent by citizens that are only validated by an authority, and discriminate the user account type based on the active session to provide only the data that can be visualized by that client. To implement this functionality, the DataAnalysisManager must be able to build a query command from the filters passed by client and also filter the results to include only the validated reports. All the reports are then sent to the client that made the request, that contains the logic for displaying in a practical way the structured data received, with the possibility to also display the data on a map, through interaction with the maps external service API.
\end{itemize}